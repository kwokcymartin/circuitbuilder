<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>HKDSE Physics Circuit Builder</title>
  <style>
    body { font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; margin: 0; overflow: hidden; }
    
    /* SIDEBAR STYLES */
    #sidebar { width: 250px; background: #f8f9fa; border-right: 1px solid #ddd; display: flex; flex-direction: column; }
    #sidebar-content { padding: 15px; overflow-y: auto; flex-grow: 1; }
    
    h3 { margin-top: 0; font-size: 14px; text-transform: uppercase; color: #555; letter-spacing: 0.5px; border-bottom: 2px solid #ddd; padding-bottom: 5px; margin-bottom: 15px; }
    
    .component-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 20px; }
    
    .comp-btn { 
      background: white; border: 1px solid #ccc; border-radius: 6px; 
      padding: 10px 5px; cursor: pointer; text-align: center;
      transition: all 0.2s; display: flex; flex-direction: column; align-items: center; justify-content: center;
      height: 70px;
    }
    .comp-btn:hover { background: #e9ecef; border-color: #adb5bd; transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    .comp-btn svg { width: 40px; height: 30px; margin-bottom: 5px; stroke: #333; stroke-width: 2; fill: none; }
    .comp-btn span { font-size: 11px; color: #333; font-weight: 500; }

    .full-width { grid-column: span 2; height: auto; flex-direction: row; gap: 10px; padding: 10px; }
    
    /* CONTROLS & PROPERTIES */
    .toggle-section { margin-bottom: 20px; background: white; padding: 10px; border-radius: 6px; border: 1px solid #eee; }
    .toggle-label { display: flex; align-items: center; font-size: 12px; margin-bottom: 6px; cursor: pointer; color: #444; }
    .toggle-label input { margin-right: 8px; }

    .prop-box { margin-top: auto; padding: 15px; background: #e8f0fe; border-top: 1px solid #d2e3fc; display: none; }
    .prop-box label { display: block; margin-bottom: 4px; font-size: 11px; font-weight: bold; color: #1967d2; }
    .prop-box input[type="text"] { width: 95%; padding: 6px; margin-bottom: 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 13px; }
    
    .export-btn { 
      width: 100%; padding: 10px; background: #34a853; color: white; border: none; 
      border-radius: 4px; font-weight: bold; cursor: pointer; margin-top: 10px; 
    }
    .export-btn:hover { background: #2d9249; }
    
    .clear-btn {
      width: 100%; padding: 8px; background: #fff; color: #d93025; border: 1px solid #d93025;
      border-radius: 4px; cursor: pointer; margin-top: 5px; font-size: 12px;
    }
    .clear-btn:hover { background: #fce8e6; }

    /* CANVAS */
    #canvas-container { flex-grow: 1; position: relative; background: #fff; cursor: crosshair; }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>

<div id="sidebar">
  <div id="sidebar-content">
    <h3>Add Components</h3>
    <div class="component-grid">
      <!-- Resistor -->
      <div class="comp-btn" onclick="addComponent('resistor')">
        <svg viewBox="-30 -15 60 30"><rect x="-25" y="-10" width="50" height="20" rx="0" /></svg>
        <span>Resistor</span>
      </div>
      <!-- Bulb -->
      <div class="comp-btn" onclick="addComponent('bulb')">
        <svg viewBox="-20 -20 40 40">
            <circle cx="0" cy="0" r="14" />
            <path d="M-20 0 L-6 0 A 6 6 0 0 1 6 0 L 20 0" stroke-width="1.5" />
        </svg>
        <span>Bulb</span>
      </div>
      <!-- Battery -->
      <div class="comp-btn" onclick="addComponent('battery')">
        <svg viewBox="-20 -20 40 40">
            <line x1="-5" y1="-12" x2="-5" y2="12" />
            <line x1="5" y1="-6" x2="5" y2="6" stroke-width="4" />
        </svg>
        <span>Battery</span>
      </div>
      <!-- Switch -->
      <div class="comp-btn" onclick="addComponent('switch')">
        <svg viewBox="-25 -15 50 30">
            <circle cx="-12" cy="0" r="3" fill="none" stroke="black" />
            <circle cx="12" cy="0" r="3" fill="none" stroke="black" />
            <line x1="-9" y1="-2" x2="8" y2="-10" />
        </svg>
        <span>Switch</span>
      </div>
      <!-- Ammeter -->
      <div class="comp-btn" onclick="addComponent('ammeter')">
        <svg viewBox="-20 -20 40 40">
            <circle cx="0" cy="0" r="14" />
            <text x="0" y="5" text-anchor="middle" font-size="16" font-family="serif" fill="black" stroke="none">A</text>
        </svg>
        <span>Ammeter</span>
      </div>
      <!-- Voltmeter -->
      <div class="comp-btn" onclick="addComponent('voltmeter')">
        <svg viewBox="-20 -20 40 40">
            <circle cx="0" cy="0" r="14" />
            <text x="0" y="5" text-anchor="middle" font-size="16" font-family="serif" fill="black" stroke="none">V</text>
        </svg>
        <span>Voltmeter</span>
      </div>
      <!-- Diode -->
      <div class="comp-btn" onclick="addComponent('diode')">
        <svg viewBox="-20 -15 40 30">
            <polygon points="-10,-10 10,0 -10,10" fill="none" stroke="black" />
            <line x1="10" y1="-10" x2="10" y2="10" />
        </svg>
        <span>Diode</span>
      </div>
      
      <!-- Wire -->
      <div class="comp-btn full-width" onclick="addWire()">
        <svg viewBox="0 0 100 20" style="width:80px; height:20px;">
            <line x1="0" y1="10" x2="100" y2="10" />
            <rect x="0" y="8" width="4" height="4" fill="#666" stroke="none"/>
            <rect x="96" y="8" width="4" height="4" fill="#666" stroke="none"/>
        </svg>
        <span>Straight Wire</span>
      </div>
    </div>

    <h3>Options</h3>
    <div class="toggle-section">
      <label class="toggle-label"><input type="checkbox" id="check-grid" checked onchange="toggleGrid(this.checked)"> Show Grid</label>
      <label class="toggle-label"><input type="checkbox" id="check-handles" checked onchange="toggleHandles(this.checked)"> Show Wire Points</label>
    </div>
    
    <button class="export-btn" onclick="exportImage()">ðŸ“· Save PNG</button>
    <button class="clear-btn" onclick="clearCanvas()">Clear All</button>
  </div>
  
  <div id="properties" class="prop-box">
    <h4>Properties</h4>
    <div id="common-props">
      <label>Label:</label>
      <input type="text" id="prop-label" oninput="updateLabel(this.value)">
      <div style="font-size:10px; color:#666; margin-bottom:8px;">Try: R_1, V_{in}, x^2, \Omega</div>
      <button onclick="deleteSelected()" style="width:100%; background:#fff; border:1px solid #d93025; color:#d93025; border-radius:3px; padding:4px; cursor:pointer;">Delete</button>
    </div>
    
    <div id="wire-props" style="display:none;">
      <label style="margin-top:10px;"><input type="checkbox" id="prop-current" onchange="toggleCurrent(this.checked)"> Show Current Arrow</label>
      <label>Current Value:</label>
      <input type="text" id="prop-current-val" oninput="updateCurrentVal(this.value)" placeholder="e.g. I = 2A">
    </div>
  </div>
</div>

<div id="canvas-container">
  <canvas id="circuitCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('circuitCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// --- State ---
let components = [];
let wires = [];
let dragging = null; // { item, type, offsetX, offsetY }
let selected = null;

let showGrid = true;
let showWireHandles = true;

const SNAP_DIST = 15;
const ALIGN_DIST = 15;
const GRID_SIZE = 20;

// --- Initialization ---
function resize() {
  const parent = canvas.parentElement;
  canvas.width = parent.clientWidth;
  canvas.height = parent.clientHeight;
  width = canvas.width;
  height = canvas.height;
  draw();
}
window.addEventListener('resize', resize);
resize();

// --- Rich Text Parser ---
function parseRichText(text) {
  let p = text
    .replace(/\\Omega/g, 'Î©').replace(/\\Delta/g, 'Î”').replace(/\\theta/g, 'Î¸')
    .replace(/\\alpha/g, 'Î±').replace(/\\beta/g, 'Î²').replace(/\\mu/g, 'Î¼')
    .replace(/\\pi/g, 'Ï€').replace(/\\rho/g, 'Ï');
  const segments = [];
  let buffer = "";
  let mode = 'normal';
  let inBrace = false;
  const flush = () => { if (buffer) { segments.push({ text: buffer, mode: mode }); buffer = ""; } };
  for (let i = 0; i < p.length; i++) {
    const char = p[i];
    if (char === '{') { inBrace = true; continue; }
    if (char === '}') { inBrace = false; flush(); mode = 'normal'; continue; }
    if (inBrace) { buffer += char; continue; }
    if (char === '_') { flush(); mode = 'sub'; }
    else if (char === '^') { flush(); mode = 'super'; }
    else if (char === ' ') { flush(); mode = 'normal'; buffer += " "; }
    else { buffer += char; }
  }
  flush();
  return segments;
}

function drawRichText(ctx, text, x, y, fontSize = 16, align='center') {
  if (!text) return;
  const segments = parseRichText(text);
  
  let totalWidth = 0;
  ctx.save();
  for (let seg of segments) {
    let fSize = (seg.mode !== 'normal') ? fontSize * 0.7 : fontSize;
    for (let char of seg.text) {
      let isItalic = /[a-zA-Z]/.test(char);
      ctx.font = `${isItalic ? 'italic ' : ''}${fSize}px "Times New Roman", serif`;
      totalWidth += ctx.measureText(char).width;
    }
  }
  ctx.restore();

  ctx.save();
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = 'black';
  
  let cursorX = (align === 'center') ? x - totalWidth / 2 : x;
  
  for (let seg of segments) {
    let fSize = (seg.mode !== 'normal') ? fontSize * 0.7 : fontSize;
    let yOffset = (seg.mode === 'sub') ? fontSize * 0.35 : (seg.mode === 'super' ? -fontSize * 0.4 : 0);
    
    for (let char of seg.text) {
      let isItalic = /[a-zA-Z]/.test(char);
      ctx.font = `${isItalic ? 'italic ' : ''}${fSize}px "Times New Roman", serif`;
      ctx.fillText(char, cursorX, y + yOffset);
      cursorX += ctx.measureText(char).width;
    }
  }
  ctx.restore();
}

// --- Models ---
class Component {
  constructor(type, x, y) {
    this.type = type;
    this.x = x;
    this.y = y;
    this.label = "";
    // Label position relative to component center
    this.labelX = 0; 
    this.labelY = -35; 
    this.nodes = this.getNodesConfig(type);
  }

  getNodesConfig(type) {
    switch(type) {
      case 'resistor': return [{x:-30, y:0}, {x:30, y:0}];
      case 'bulb': return [{x:-20, y:0}, {x:20, y:0}];
      case 'battery': return [{x:-20, y:0}, {x:20, y:0}];
      case 'switch': return [{x:-25, y:0}, {x:25, y:0}]; 
      case 'ammeter':
      case 'voltmeter': return [{x:-20, y:0}, {x:20, y:0}];
      case 'diode': return [{x:-20, y:0}, {x:20, y:0}];
      default: return [{x:-20, y:0}, {x:20, y:0}];
    }
  }

  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.strokeStyle = selected === this ? '#2196F3' : 'black';
    ctx.lineWidth = 2;
    ctx.fillStyle = 'white';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    switch(this.type) {
      case 'resistor':
        ctx.fillRect(-25, -10, 50, 20); ctx.strokeRect(-25, -10, 50, 20);
        ctx.beginPath(); ctx.moveTo(-30,0); ctx.lineTo(-25,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(25,0); ctx.lineTo(30,0); ctx.stroke();
        break;
      case 'bulb':
        ctx.beginPath(); ctx.arc(0,0, 15, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-6, 0); ctx.arc(0, 0, 6, Math.PI, 0); ctx.lineTo(20, 0); ctx.stroke();
        break;
      case 'battery':
        ctx.beginPath(); ctx.moveTo(-5, -15); ctx.lineTo(-5, 15); ctx.stroke();
        ctx.beginPath(); ctx.lineWidth = 4; ctx.moveTo(5, -8); ctx.lineTo(5, 8); ctx.stroke();
        ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-5, 0); ctx.moveTo(5, 0); ctx.lineTo(20, 0); ctx.stroke();
        break;
      case 'switch':
        ctx.beginPath(); ctx.arc(-15, 0, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(15, 0, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-11, -2); ctx.lineTo(10, -12); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-25,0); ctx.lineTo(-19,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(25,0); ctx.lineTo(19,0); ctx.stroke();
        break;
      case 'ammeter':
      case 'voltmeter':
        ctx.beginPath(); ctx.arc(0,0, 15, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = 'black'; ctx.font = 'bold 16px "Times New Roman", serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.type === 'ammeter' ? 'A' : 'V', 0, 1);
        ctx.beginPath(); ctx.moveTo(-20,0); ctx.lineTo(-15,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(20,0); ctx.stroke();
        break;
      case 'diode':
        ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(10, 0); ctx.lineTo(-10, 10); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10, -10); ctx.lineTo(10, 10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-20,0); ctx.lineTo(-10,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(20,0); ctx.stroke();
        break;
    }
    
    // Draw Label (Movable)
    if (this.label) {
      ctx.fillStyle = selected === this ? '#2196F3' : 'black';
      // Draw a small invisible handle box if selected?
      if (selected === this) {
          ctx.beginPath();
          ctx.arc(this.labelX, this.labelY, 3, 0, Math.PI*2);
          ctx.fill();
      }
      drawRichText(ctx, this.label, this.labelX, this.labelY, 18, 'center');
    }
    
    ctx.restore();
  }

  getNodesAbs() { return this.nodes.map(n => ({x: this.x + n.x, y: this.y + n.y})); }
}

class Wire {
  constructor(x1, y1, x2, y2) {
    this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
    this.showCurrent = false; this.currentLabel = "";
  }
  draw(ctx) {
    ctx.strokeStyle = selected === this ? '#2196F3' : 'black';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(this.x1, this.y1); ctx.lineTo(this.x2, this.y2); ctx.stroke();
    if (showWireHandles || selected === this) {
      ctx.fillStyle = selected === this ? '#2196F3' : '#666';
      const s = 6; ctx.fillRect(this.x1 - s/2, this.y1 - s/2, s, s); ctx.fillRect(this.x2 - s/2, this.y2 - s/2, s, s);
    }
    if (this.showCurrent) {
      const mx = (this.x1 + this.x2) / 2, my = (this.y1 + this.y2) / 2;
      const angle = Math.atan2(this.y2 - this.y1, this.x2 - this.x1);
      ctx.save(); ctx.translate(mx, my); ctx.rotate(angle);
      ctx.fillStyle = 'red'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-10, -5); ctx.lineTo(-10, 5); ctx.fill();
      if (this.currentLabel) { ctx.restore(); ctx.save(); ctx.translate(mx, my - 18); drawRichText(ctx, this.currentLabel, 0, 0, 18); }
      ctx.restore();
    }
  }
}

// --- Global Functions ---
function addComponent(type) { components.push(new Component(type, width/2, height/2)); draw(); }
function addWire() { wires.push(new Wire(width/2 - 50, height/2, width/2 + 50, height/2)); draw(); }
function toggleGrid(val) { showGrid = val; draw(); }
function toggleHandles(val) { showWireHandles = val; draw(); }
function clearCanvas() { if(confirm("Clear diagram?")) { components = []; wires = []; selected = null; document.querySelector('.prop-box').style.display = 'none'; draw(); } }
function deleteSelected() { 
  if (selected) {
    if (selected instanceof Component) components = components.filter(c => c !== selected);
    else wires = wires.filter(w => w !== selected);
    selected = null; document.querySelector('.prop-box').style.display = 'none'; draw();
  }
}
function exportImage() {
  const tCanvas = document.createElement('canvas'); tCanvas.width = width; tCanvas.height = height;
  const tCtx = tCanvas.getContext('2d');
  tCtx.fillStyle = 'white'; tCtx.fillRect(0,0,width,height);
  if (showGrid) {
    tCtx.beginPath(); tCtx.strokeStyle = '#f0f0f0'; tCtx.lineWidth = 1;
    for(let i=0; i<width; i+=20) { tCtx.moveTo(i,0); tCtx.lineTo(i,height); }
    for(let i=0; i<height; i+=20) { tCtx.moveTo(0,i); tCtx.lineTo(width,i); }
    tCtx.stroke();
  }
  let oldH = showWireHandles, oldS = selected; showWireHandles = false; selected = null;
  wires.forEach(w => w.draw(tCtx)); components.forEach(c => c.draw(tCtx));
  showWireHandles = oldH; selected = oldS;
  const link = document.createElement('a'); link.download = 'circuit.png'; link.href = tCanvas.toDataURL(); link.click();
}

// --- Interaction ---
function getMouse(e) { const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }

function hitTest(x, y) {
  // 1. Wire Ends
  for (let w of wires) {
    if (Math.hypot(w.x1-x, w.y1-y) < 10) return { item: w, type: 'wireStart' };
    if (Math.hypot(w.x2-x, w.y2-y) < 10) return { item: w, type: 'wireEnd' };
  }
  // 2. Components & Labels
  for (let c of components) {
    // Check Label Handle (if label exists)
    if (c.label) {
      // Global position of label handle
      const lx = c.x + c.labelX;
      const ly = c.y + c.labelY;
      if (Math.hypot(x - lx, y - ly) < 15) { // Generous hit area for text
        return { item: c, type: 'label', offsetX: x - lx, offsetY: y - ly };
      }
    }
    // Check Component Body
    if (x > c.x-30 && x < c.x+30 && y > c.y-25 && y < c.y+25) return { item: c, type: 'component', offsetX: x-c.x, offsetY: y-c.y };
  }
  // 3. Wire Body
  for (let w of wires) {
    const A = x - w.x1, B = y - w.y1, C = w.x2 - w.x1, D = w.y2 - w.y1;
    const dot = A * C + B * D, len_sq = C * C + D * D;
    let param = -1; if (len_sq != 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = w.x1; yy = w.y1; } else if (param > 1) { xx = w.x2; yy = w.y2; } else { xx = w.x1 + param * C; yy = w.y1 + param * D; }
    if (Math.hypot(x - xx, y - yy) < 5) return { 
        item: w, type: 'wireBody', 
        dx1: w.x1 - x, dy1: w.y1 - y, dx2: w.x2 - x, dy2: w.y2 - y 
    };
  }
  return null;
}

canvas.addEventListener('mousedown', e => {
  const {x, y} = getMouse(e);
  const hit = hitTest(x, y);
  if (hit) { dragging = hit; selectItem(hit.item); }
  else { selected = null; document.querySelector('.prop-box').style.display = 'none'; draw(); }
});

canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  const {x, y} = getMouse(e);

  if (dragging.type === 'component') {
    let tx = x - dragging.offsetX, ty = y - dragging.offsetY;
    if (Math.abs(tx % GRID_SIZE) < SNAP_DIST) tx = Math.round(tx / GRID_SIZE) * GRID_SIZE;
    if (Math.abs(ty % GRID_SIZE) < SNAP_DIST) ty = Math.round(ty / GRID_SIZE) * GRID_SIZE;
    dragging.item.x = tx; dragging.item.y = ty;
  }
  else if (dragging.type === 'label') {
    // Move label RELATIVE to component center
    // Global mouse X - Component X = Relative Label X
    // We add offset to keep cursor relative to text anchor
    dragging.item.labelX = (x - dragging.item.x) - dragging.offsetX;
    dragging.item.labelY = (y - dragging.item.y) - dragging.offsetY;
  }
  else if (dragging.type === 'wireStart' || dragging.type === 'wireEnd') {
    const w = dragging.item;
    let tx = x, ty = y;
    const ax = (dragging.type === 'wireStart') ? w.x2 : w.x1;
    const ay = (dragging.type === 'wireStart') ? w.y2 : w.y1;
    let snapped = false;

    for (let c of components) {
      for (let n of c.getNodesAbs()) {
        if (Math.hypot(n.x - x, n.y - y) < SNAP_DIST) { tx = n.x; ty = n.y; snapped = true; break; }
      }
      if (snapped) break;
    }
    if (!snapped) {
      for (let otherW of wires) {
        if (otherW === w) continue;
        if (Math.hypot(otherW.x1 - x, otherW.y1 - y) < SNAP_DIST) { tx = otherW.x1; ty = otherW.y1; snapped = true; break; }
        if (Math.hypot(otherW.x2 - x, otherW.y2 - y) < SNAP_DIST) { tx = otherW.x2; ty = otherW.y2; snapped = true; break; }
      }
    }
    if (!snapped) {
      if (Math.abs(tx % GRID_SIZE) < SNAP_DIST) tx = Math.round(tx / GRID_SIZE) * GRID_SIZE;
      if (Math.abs(ty % GRID_SIZE) < SNAP_DIST) ty = Math.round(ty / GRID_SIZE) * GRID_SIZE;
    }
    if (!snapped) {
      if (Math.abs(ty - ay) < ALIGN_DIST) ty = ay;
      if (Math.abs(tx - ax) < ALIGN_DIST) tx = ax;
    }

    if (dragging.type === 'wireStart') { w.x1 = tx; w.y1 = ty; }
    else { w.x2 = tx; w.y2 = ty; }
  }
  else if (dragging.type === 'wireBody') {
    const w = dragging.item;
    w.x1 = x + dragging.dx1; w.y1 = y + dragging.dy1;
    w.x2 = x + dragging.dx2; w.y2 = y + dragging.dy2;
  }

  draw();
});

canvas.addEventListener('mouseup', () => dragging = null);

function selectItem(item) {
  selected = item;
  const box = document.querySelector('.prop-box');
  const wireProps = document.getElementById('wire-props');
  const commonProps = document.getElementById('common-props');
  const labelInput = document.getElementById('prop-label');
  
  box.style.display = 'block';
  
  if (item instanceof Component) {
    wireProps.style.display = 'none'; commonProps.style.display = 'block';
    labelInput.value = item.label;
  } else if (item instanceof Wire) {
    wireProps.style.display = 'block'; commonProps.style.display = 'none';
    document.getElementById('prop-current').checked = item.showCurrent;
    document.getElementById('prop-current-val').value = item.currentLabel;
  }
  draw();
}

function updateLabel(val) { if (selected && selected instanceof Component) { selected.label = val; draw(); } }
function toggleCurrent(checked) { if (selected && selected instanceof Wire) { selected.showCurrent = checked; draw(); } }
function updateCurrentVal(val) { if (selected && selected instanceof Wire) { selected.currentLabel = val; draw(); } }

function draw() {
  ctx.clearRect(0, 0, width, height);
  if (showGrid) {
    ctx.beginPath(); ctx.strokeStyle = '#f0f0f0'; ctx.lineWidth = 1;
    for(let i=0; i<width; i+=20) { ctx.moveTo(i,0); ctx.lineTo(i,height); }
    for(let i=0; i<height; i+=20) { ctx.moveTo(0,i); ctx.lineTo(width,i); }
    ctx.stroke();
  }
  wires.forEach(w => w.draw(ctx));
  components.forEach(c => c.draw(ctx));
}
</script>
</body>
</html>
